;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname ex477) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
; [List-of X] -> [List-of [List-of X]]
; creates a list of all rearrangements of the items in w
(define (arrangements w)
  (cond
    [(empty? w) '(())]
    [else
      (foldr
       (lambda (item others)
         (local ((define without-item (arrangements (remove item w)))
                 (define add-item-to-front
                   (map (lambda (a) (cons item a)) without-item)))
           ; – IN –
           (append add-item-to-front others)))
       '()
       w)]))
 
(define (all-words-from-rat? w)
  (and (member (explode "rat") w)
       (member (explode "art") w)
       (member (explode "tar") w)
       (member (explode "tra") w)
       (member (explode "atr") w)
       (member (explode "rta") w)))
 
(check-satisfied (arrangements '("r" "a" "t"))
                 all-words-from-rat?)

; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

; Design of arrangements.
    ; NOTE on foldr.
    ; The reduction through foldr is necessary here because the new problems
    ; generated by the algorithm return lists of lists as solutions. The foldr
    ; function itself takes a process, here the (lambda ...) part, a base value
    ; that is the starting value for the reduction, here '(), and an argument to
    ; to loop over, here w.
    ; END NOTE on foldr.
    ; The algorithm has three parts:
    ;     1. Generate new problems and solve them.
    ;        (arrangements (remove item w))
    ;     2. First step in recombining solutions by adding back
    ;        the removed item.
    ;        (map (lambda (a) (cons item a)) without-item)
    ;     3. Second step in recombining solutions by reducing the return values
    ;        of the new problems to a single list.
    ;        (append add-item-to-front others)

; What is a trivially solvable problem?
    ; An empty [List-of X], as its solution is a list containing '().

; How are trivial solutions solved?
    ; Return a list containing an empty list.

; How does the algorithm generate new problems that are more easily solvable
; than the original one? Is there one new problem that we generate or are there
; several?
    ; The algorithm generates new problems by removing one item from its
    ; argument and then dealing with this new, smaller problem first. It
    ; then adds the removed item to the front of every element of this
    ; smaller solution.
    ; It does so for every item in its argument, thus resulting in as
    ; many new problems as there are elments in the argument.

; Is the solution of the given problem the same as the solution of (one of) the
; new problems? Or, do we need to combine the solutions to create a solution for
; the original problem? And, if so, do we need anything from the original
; problem data?
    ; The new problems have a different solution than the given problem since
    ; one of the items from the original problem has been removed for every
    ; new problem. This removed item has then to be added back to the solutions
    ; of the new problems.

; Termination.
    ; This algorithm terminates, because eventually it will reach the end of the
    ; the list, thus resulting in a trivial problem.

; Does arrangements create the same lists as the solution of Word Games,
; the Heart of the Problem (ex214.rkt)?
    ; The order of the items is somewhat different, owing to the different
    ; approach.
